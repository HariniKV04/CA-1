# -*- coding: utf-8 -*-
"""DSP_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SP8CMOhZJrqlBHYBR1CsJRKXBIFgpx32

# **Q1 - Ceasar**
"""

def caesar_encrypt(plaintext, key):
    """
    Encrypts a given plaintext string using the Caesar cipher.

    Args:
        plaintext (str): The string to be encrypted.
        key (int): The shift value (1-25).

    Returns:
        str: The encrypted ciphertext string.
    """
    encrypted_text = ""
    for char in plaintext:
        # Check if the character is an alphabet letter
        if char.isalpha():
            # Determine the starting ASCII value ('a' or 'A')
            start = ord('a') if char.islower() else ord('A')

            # Convert character to a number (0-25)
            p = ord(char) - start

            # Apply the encryption formula: C = (P + k) mod 26
            c = (p + key) % 26

            # Convert the number back to a character and append
            encrypted_text += chr(c + start)
        else:
            # If not a letter, keep the character as is
            encrypted_text += char

    return encrypted_text


def caesar_decrypt(ciphertext, key):
    """
    Decrypts a given ciphertext string using the Caesar cipher.

    Args:
        ciphertext (str): The string to be decrypted.
        key (int): The shift value (1-25) used for encryption.

    Returns:
        str: The decrypted plaintext string.
    """
    decrypted_text = ""
    for char in ciphertext:
        # Check if the character is an alphabet letter
        if char.isalpha():
            # Determine the starting ASCII value ('a' or 'A')
            start = ord('a') if char.islower() else ord('A')

            # Convert character to a number (0-25)
            c = ord(char) - start

            # Apply the decryption formula: P = (C - k) mod 26
            p = (c - key) % 26

            # Convert the number back to a character and append
            decrypted_text += chr(p + start)
        else:
            # If not a letter, keep the character as is
            decrypted_text += char

    return decrypted_text


print("--- Caesar Cipher Program ---")

# Get user input for the message
message = input("Enter the string: ")

# Get and validate the key from the user
while True:
    try:
        k = int(input("Enter the key (a number from 1 to 25): "))
        if 1 <= k <= 25:
            break  # Exit the loop if the key is valid
        else:
            print("Invalid key. Please enter a number between 1 and 25.")
    except ValueError:
        print("Invalid input. Please enter a whole number.")

# Perform encryption and decryption and show the results
encrypted = caesar_encrypt(message, k)
print(f"\nPlaintext:     '{message}'")
print(f"Encrypted:     '{encrypted}'")

decrypted = caesar_decrypt(encrypted, k)
print(f"Decrypted:     '{decrypted}'")

# Brute Force (Included)
# -----------


def caesar_encrypt(plaintext, key):
    """
    Encrypts a given plaintext string using the Caesar cipher.

    Args:
        plaintext (str): The string to be encrypted.
        key (int): The shift value (1-25).

    Returns:
        str: The encrypted ciphertext string.
    """
    encrypted_text = ""
    for char in plaintext:
        # Check if the character is an alphabet letter
        if char.isalpha():
            # Determine the starting ASCII value ('a' or 'A')
            start = ord('a') if char.islower() else ord('A')

            # Convert character to a number (0-25)
            p = ord(char) - start

            # Apply the encryption formula: C = (P + k) mod 26
            c = (p + key) % 26

            # Convert the number back to a character and append
            encrypted_text += chr(c + start)
        else:
            # If not a letter, keep the character as is
            encrypted_text += char

    return encrypted_text


def caesar_decrypt(ciphertext, key):
    """
    Decrypts a given ciphertext string using the Caesar cipher.

    Args:
        ciphertext (str): The string to be decrypted.
        key (int): The shift value (1-25) used for encryption.

    Returns:
        str: The decrypted plaintext string.
    """
    decrypted_text = ""
    for char in ciphertext:
        # Check if the character is an alphabet letter
        if char.isalpha():
            # Determine the starting ASCII value ('a' or 'A')
            start = ord('a') if char.islower() else ord('A')

            # Convert character to a number (0-25)
            c = ord(char) - start

            # Apply the decryption formula: P = (C - k) mod 26
            p = (c - key) % 26

            # Convert the number back to a character and append
            decrypted_text += chr(p + start)
        else:
            # If not a letter, keep the character as is
            decrypted_text += char

    return decrypted_text


print("--- Caesar Cipher Program ---")

# Get user input for the message
message = input("Enter the string: ")

# Get and validate the key from the user
while True:
    try:
        k = int(input("Enter the key (a number from 1 to 25): "))
        if 1 <= k <= 25:
            break  # Exit the loop if the key is valid
        else:
            print("Invalid key. Please enter a number between 1 and 25.")
    except ValueError:
        print("Invalid input. Please enter a whole number.")

# Perform encryption and decryption and show the results
encrypted = caesar_encrypt(message, k)
print(f"\nPlaintext:     '{message}'")
print(f"Encrypted:     '{encrypted}'")

decrypted = caesar_decrypt(encrypted, k)
print(f"Decrypted:     '{decrypted}'")

# -------------------------------
# Brute-force decryption section
# -------------------------------
print("\n--- Brute Force Decryption of Cipher Text ---")
cipher_input = input("Enter ciphertext to brute-force: ")
for key in range(1, 26):
    possible_plaintext = caesar_decrypt(cipher_input, key)
    print(f"Key {key:2d}: {possible_plaintext}")

"""# **Q2 - Permutation**"""

import math

def find_factors(n):
    """
    Finds all integer factor pairs (m, n) for a given number.

    Args:
        n (int): The number to factor.

    Returns:
        list: A list of tuples, where each tuple is a (rows, cols) pair.
    """
    factors = []
    # Iterate from 1 up to the square root of the number
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            # i is a factor, so is n/i
            factors.append((i, n // i))
            if i*i != n: # Avoid adding the same pair twice for perfect squares
                factors.append((n // i, i))
    return sorted(factors)

def permutation_encrypt(plaintext, m, n):
    """
    Encrypts plaintext using a matrix transposition cipher.

    Args:
        plaintext (str): The string to be encrypted.
        m (int): The number of rows in the matrix.
        n (int): The number of columns in the matrix.

    Returns:
        str: The encrypted ciphertext, or an error string if dimensions are wrong.
    """
    if len(plaintext) > m * n:
        return f"Error: Plaintext is too long for a {m}x{n} matrix."

    # Pad the plaintext with a neutral character if it's too short
    plaintext = plaintext.ljust(m * n, 'X')

    # 1. Create the m x n matrix (list of lists)
    matrix = [['' for _ in range(n)] for _ in range(m)]

    # 2. Fill the matrix row by row
    char_index = 0
    for r in range(m):
        for c in range(n):
            matrix[r][c] = plaintext[char_index]
            char_index += 1

    # 3. Read the ciphertext out column by column
    ciphertext = ""
    for c in range(n):
        for r in range(m):
            ciphertext += matrix[r][c]

    return ciphertext

def permutation_decrypt(ciphertext, m, n):
    """
    Decrypts ciphertext that was encrypted with a matrix transposition.

    Args:
        ciphertext (str): The string to be decrypted.
        m (int): The number of rows in the ORIGINAL plaintext matrix.
        n (int): The number of columns in the ORIGINAL plaintext matrix.

    Returns:
        str: The decrypted plaintext.
    """
    if len(ciphertext) != m * n:
        return f"Error: Ciphertext length ({len(ciphertext)}) does not match matrix size {m}x{n} ({m*n})."

    # 1. Create the m x n matrix (same dimensions as original)
    matrix = [['' for _ in range(n)] for _ in range(m)]

    # 2. Fill the matrix column by column (this reverses the encryption process)
    char_index = 0
    for c in range(n):
        for r in range(m):
            matrix[r][c] = ciphertext[char_index]
            char_index += 1

    # 3. Read the plaintext out row by row
    plaintext = ""
    for r in range(m):
        for c in range(n):
            plaintext += matrix[r][c]

    return plaintext


ciphertext = "MYAMRARUYIQTENCTORAHROYWDSOYEOUARRGDERNOGW"
text_length = len(ciphertext)

print(f"Ciphertext: {ciphertext}")
print(f"Length of ciphertext: {text_length}\n")

# 1. Find all possible (m, n) dimensions
possible_dimensions = find_factors(text_length)
print(f"Possible (m, n) matrix dimensions for length {text_length}:")
print(possible_dimensions)
print("-" * 50)
print("Attempting decryption for each possible dimension...")
print("-" * 50)

# 2. Decrypt using each possible dimension
for m, n in possible_dimensions:
    decrypted_text = permutation_decrypt(ciphertext, m, n)
    # We print it clearly so we can inspect the results
    print(f"Trying m={m}, n={n}:")
    print(f"--> {decrypted_text}\n")