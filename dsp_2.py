# -*- coding: utf-8 -*-
"""DSP-2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cHaTg-EOLvuhlhPWIFv7my6Jo9rYeYGu

# **Q1**
"""

def caesar_encrypt(plaintext, key):
    """
    Encrypts a given plaintext string using the Caesar cipher.

    Args:
        plaintext (str): The string to be encrypted.
        key (int): The shift value (1-25).

    Returns:
        str: The encrypted ciphertext string.
    """
    encrypted_text = ""
    for char in plaintext:
        # Check if the character is an alphabet letter
        if char.isalpha():
            # Determine the starting ASCII value ('a' or 'A')
            start = ord('a') if char.islower() else ord('A')

            # Convert character to a number (0-25)
            p = ord(char) - start

            # Apply the encryption formula: C = (P + k) mod 26
            c = (p + key) % 26

            # Convert the number back to a character and append
            encrypted_text += chr(c + start)
        else:
            # If not a letter, keep the character as is
            encrypted_text += char

    return encrypted_text


def caesar_decrypt(ciphertext, key):
    """
    Decrypts a given ciphertext string using the Caesar cipher.

    Args:
        ciphertext (str): The string to be decrypted.
        key (int): The shift value (1-25) used for encryption.

    Returns:
        str: The decrypted plaintext string.
    """
    decrypted_text = ""
    for char in ciphertext:
        # Check if the character is an alphabet letter
        if char.isalpha():
            # Determine the starting ASCII value ('a' or 'A')
            start = ord('a') if char.islower() else ord('A')

            # Convert character to a number (0-25)
            c = ord(char) - start

            # Apply the decryption formula: P = (C - k) mod 26
            p = (c - key) % 26

            # Convert the number back to a character and append
            decrypted_text += chr(p + start)
        else:
            # If not a letter, keep the character as is
            decrypted_text += char

    return decrypted_text

print("--- Caesar Cipher Brute-Force Decryptor ---")
# Get user input for the message
ciphertext = input("Enter the string: ")
print("Attempting all possible keys (1-25):\n")

# Loop through every possible key
for key in range(1, 26):
    # Decrypt the message with the current key
    plaintext_guess = caesar_decrypt(ciphertext, key)

    # Print the key and the result. The :2 formats the number to take 2 spaces
    # for clean alignment.
    print(f"Key {key:2}: {plaintext_guess}")

"""# **Q2**"""

def vigenere_encrypt(message, keyword):
    """
    Encrypts a message using the Vigenère cipher.

    Args:
        message (str): The plaintext message to be encrypted.
        keyword (str): The keyword for the cipher.

    Returns:
        str: The encrypted ciphertext.
    """
    encrypted_message = ""
    # Ensure both message and keyword are uppercase for simplicity
    message = message.upper()
    keyword = keyword.upper()

    # Repeat the keyword to match the length of the message
    full_key = ""
    key_index = 0
    for char in message:
        # We only create key characters for actual letters in the message
        if 'A' <= char <= 'Z':
            full_key += keyword[key_index % len(keyword)]
            key_index += 1
        else:
            # Add a placeholder for non-alphabetic characters
            full_key += ' '

    # --- CORRECTED PRINT STATEMENTS ---
    # Create the formatted strings first, then print, to avoid nested f-string errors.
    original_display = ' '.join([f"{c}({ord(c) - ord('A')})" for c in message if 'A' <= c <= 'Z'])
    keyword_display = ' '.join([f"{c}({ord(c) - ord('A')})" for c in full_key.replace(' ', '')])

    print(f"Original : {original_display}")
    print(f"Keyword  : {keyword_display}")

    add_shift_values = []
    mod_26_values = []

    for i in range(len(message)):
        if 'A' <= message[i] <= 'Z':
            # Get the corresponding numbers for the message and keyword letters
            message_num = ord(message[i]) - ord('A')
            keyword_num = ord(full_key[i]) - ord('A')

            # Add the value of the keyword letter to the original letter
            added_value = message_num + keyword_num
            add_shift_values.append(str(added_value))

            # Reduce the answer mod 26
            mod_value = added_value % 26
            mod_26_values.append(str(mod_value))

            # Translate the number back to a letter
            encrypted_char = chr(mod_value + ord('A'))
            encrypted_message += encrypted_char
        else:
            # If the character is not a letter, keep it as is.
            encrypted_message += message[i]
            add_shift_values.append(' ')
            mod_26_values.append(' ')

    # Print the intermediate steps as in the example
    print(f"Add Shift: {' '.join(add_shift_values)}")
    print(f"Mod 26   : {' '.join(mod_26_values)}")
    print(f"Final    : {' '.join(list(encrypted_message))}")

    return encrypted_message

# --- Example from your request ---
message_to_encrypt = "Vigenere"
encryption_key = "Key"

print("--- Encrypting 'Vigenere' with keyword 'Key' ---")
final_result = vigenere_encrypt(message_to_encrypt, encryption_key)
print(f"\nEncrypted Message: {final_result}")

"""# **Q3**"""

import collections

def frequency_analysis(text):
    """
    Counts the frequency of each letter in a given text.

    Args:
        text (str): The input string (ciphertext).

    Returns:
        list: A list of characters sorted by frequency, from most to least common.
    """
    # Count only alphabetic characters
    frequencies = collections.Counter(c for c in text.upper() if 'A' <= c <= 'Z')
    # Return sorted list of characters by their frequency
    return [item[0] for item in frequencies.most_common()]

def decrypt_caesar(ciphertext, shift):
    """
    Decrypts a Caesar cipher for a given shift.

    Args:
        ciphertext (str): The text to be decrypted.
        shift (int): The numerical key to shift letters back by.

    Returns:
        str: The decrypted plaintext.
    """
    decrypted_text = ""
    for char in ciphertext:
        if 'A' <= char <= 'Z':
            # Shift the character back, handling wraparound with modulo
            original_pos = ord(char) - ord('A')
            shifted_pos = (original_pos - shift + 26) % 26
            decrypted_text += chr(shifted_pos + ord('A'))
        elif 'a' <= char <= 'z':
            original_pos = ord(char) - ord('a')
            shifted_pos = (original_pos - shift + 26) % 26
            decrypted_text += chr(shifted_pos + ord('a'))
        else:
            # Keep non-alphabetic characters (spaces, punctuation) as they are
            decrypted_text += char
    return decrypted_text

def crack_cipher(ciphertext):
    """
    Cracks a Caesar cipher using frequency analysis.
    Assumes the most frequent letter in the ciphertext corresponds to 'E'.

    Args:
        ciphertext (str): The encrypted message.

    Returns:
        str: The decrypted plaintext.
    """
    # In English, 'E' is the most common letter.
    most_common_english_letter = 'E'

    # 1. Find the most frequent letter in the ciphertext
    frequent_chars = frequency_analysis(ciphertext)
    if not frequent_chars:
        return "Ciphertext contains no letters to analyze."
    most_frequent_cipher_char = frequent_chars[0]

    # 2. Calculate the shift
    # This is the difference in alphabet position between the most common
    # ciphertext letter and the letter 'E'.
    shift = (ord(most_frequent_cipher_char) - ord(most_common_english_letter)) % 26

    print(f"Most frequent character is '{most_frequent_cipher_char}'. Assuming it was 'E'.")
    print(f"Calculated shift: {shift}\n")

    # 3. Decrypt using the calculated shift
    return decrypt_caesar(ciphertext, shift)

# --- Ciphertexts to be solved ---

cipher_a = "cxknxawxccxkncqjcrbcqnzdnbcrxwfruurjvbqjtnbynjan"
cipher_b = "HUFDHF, P RLLW WPJABYPUN HSS AOLzl SPAASL RPKZ WSHFPUN ZVTL NHTL PU AOPZ IPN MPLSK VM YFL HUK HSS. AOVBZHUKZ VM SPAASL RPKZ, HUK UVIVKFZ HYVBUK - UVIVKF IPN, P TLHU - LEJLWA TL. HUK P'T ZAHUKPUN VU AOL LKNL VM ZVTL JYHGF JSPMM. DOHA P OHCL AV KV, P OHCL AV JHAJO LCLYFIVKF PM AOLF ZAHYA AV NV VCLY AOL JSPMM - P TLHU PM AOLF'YL YBUUPUN HUK AOLF KVU'A SVVR DOLYL AOLF'YL NVPUN P OHCL AV JVTL VBA MYVT ZVTLDOLYL HUK JHAJO AOLT. AOHA'Z HSS P'K KV HSS KHF. P'K QBZA IL AOL JHAJOLY PU AOL YFL, HUK HSS. P RUVD PA'Z JYHGF, IBA AOHA'Z AOL VUSF AOPUN P'K YLHSSF SPRL AV IL. P RUVD PA'Z JYHGF."
cipher_c = "ODOQVS KSRRWBU DFOMSF BCK MCI KWZZ TSSZ BC FOWB, TCF SOQV CT MCI KWZZ PS GVSZHSF HC HVS CHVSF. BCK MCI KWZZ TSSZ BC QCZR, TCF SOQV CT MCI KWZZ PS KOFAHV HC HVS CHVSF. BCK HVSFS WG BC ACFS ZCBSZWBSGG, TCF SOQV CT MCI KWZZ PS QCADOBWCB HC HVS CHVSF. BCK MCI OFS HKC PCRWSG, PIH HVSFS WG CBZM CBS ZWTS PSTCFS MCI. UC BCK HC MCIF RKSZZWBU DZOQS HC SBHSF WBHC HVS ROMG CT MCIF HCUSHVSFBSGG OBR AOM MCIF ROMG PS UCCR OBR ZCBU IDCB HVS SOFHV."

# --- Solve and Print Results ---

print("--- Solving Cipher (a) ---")
plaintext_a = crack_cipher(cipher_a.upper()) # Convert to upper for analysis
print(f"Decrypted Text (a):\n{plaintext_a.lower()}\n") # Display as lower to match original case

print("--- Solving Cipher (b) ---")
plaintext_b = crack_cipher(cipher_b)
print(f"Decrypted Text (b):\n{plaintext_b}\n")

print("--- Solving Cipher (c) ---")
plaintext_c = crack_cipher(cipher_c)
print(f"Decrypted Text (c):\n{plaintext_c}\n")

"""# **Q4**"""

def generate_key_matrix(key):
    key = key.lower().replace("j", "i")
    key_unique = ''.join(sorted(set(key), key=key.index))
    alphabet = 'abcdefghiklmnopqrstuvwxyz'  # 'j' excluded
    full_key = key_unique + ''.join(c for c in alphabet if c not in key_unique)
    matrix = [list(full_key[i:i+5]) for i in range(0, 25, 5)]
    return matrix

def print_matrix(matrix):
    print("\nPlayfair Cipher Key Matrix:")
    for row in matrix:
        print(' '.join(row))
    print()

def find_position(matrix, char):
    for row in range(5):
        for col in range(5):
            if matrix[row][col] == char:
                return row, col
    return None

def preprocess_text(text):
    text = text.lower().replace("j", "i")
    text = ''.join(filter(str.isalpha, text))
    i = 0
    result = ""
    while i < len(text):
        a = text[i]
        b = ''
        if i + 1 < len(text):
            b = text[i + 1]
        if a == b:
            result += a + 'z'
            i += 1
        else:
            result += a
            if b:
                result += b
                i += 2
            else:
                i += 1
    if len(result) % 2 != 0:
        result += 'z'
    return result

def encrypt_pair(matrix, a, b):
    row1, col1 = find_position(matrix, a)
    row2, col2 = find_position(matrix, b)

    if row1 == row2:
        enc1 = matrix[row1][(col1 + 1) % 5]
        enc2 = matrix[row2][(col2 + 1) % 5]
        rule = "Same row"
    elif col1 == col2:
        enc1 = matrix[(row1 + 1) % 5][col1]
        enc2 = matrix[(row2 + 1) % 5][col2]
        rule = "Same column"
    else:
        enc1 = matrix[row1][col2]
        enc2 = matrix[row2][col1]
        rule = "Rectangle rule"

    print(f"{a.upper()} {b.upper()} -> {enc1.upper()}{enc2.upper()}  ({rule})")
    return enc1 + enc2

def playfair_encrypt(plaintext, key="monarchy"):
    matrix = generate_key_matrix(key)
    print_matrix(matrix)

    plaintext = preprocess_text(plaintext)
    print("Processed Plaintext (in pairs):", ' '.join([plaintext[i:i+2] for i in range(0, len(plaintext), 2)]))
    print("\nEncryption steps:")

    ciphertext = ""
    for i in range(0, len(plaintext), 2):
        a = plaintext[i]
        b = plaintext[i + 1]
        ciphertext += encrypt_pair(matrix, a, b)

    return ciphertext.upper()

# Example usage:
plaintext = "we are discovered, save yourself"
cipher_text = playfair_encrypt(plaintext, key="monarchy")
print("\nFinal Cipher Text:", cipher_text)

def generate_key_matrix(key):
    key = key.lower().replace("j", "i")
    key_unique = ''.join(sorted(set(key), key=key.index))
    alphabet = 'abcdefghiklmnopqrstuvwxyz'
    full_key = key_unique + ''.join(c for c in alphabet if c not in key_unique)
    matrix = [list(full_key[i:i+5]) for i in range(0, 25, 5)]
    return matrix

def print_matrix(matrix):
    print("\nPlayfair Cipher Key Matrix:")
    for row in matrix:
        print(' '.join(row))
    print()

def find_position(matrix, char):
    for row in range(5):
        for col in range(5):
            if matrix[row][col] == char:
                return row, col
    return None

def decrypt_pair(matrix, a, b):
    row1, col1 = find_position(matrix, a)
    row2, col2 = find_position(matrix, b)

    if row1 == row2:
        dec1 = matrix[row1][(col1 - 1) % 5]
        dec2 = matrix[row2][(col2 - 1) % 5]
        rule = "Same row"
    elif col1 == col2:
        dec1 = matrix[(row1 - 1) % 5][col1]
        dec2 = matrix[(row2 - 1) % 5][col2]
        rule = "Same column"
    else:
        dec1 = matrix[row1][col2]
        dec2 = matrix[row2][col1]
        rule = "Rectangle rule"

    print(f"{a.upper()} {b.upper()} -> {dec1.upper()}{dec2.upper()}  ({rule})")
    return dec1 + dec2

def playfair_decrypt(ciphertext, key="monarchy"):
    matrix = generate_key_matrix(key)
    print_matrix(matrix)

    ciphertext = ciphertext.lower().replace("j", "i")
    ciphertext = ''.join(filter(str.isalpha, ciphertext))
    print("Cipher Text (in pairs):", ' '.join([ciphertext[i:i+2] for i in range(0, len(ciphertext), 2)]))
    print("\nDecryption steps:")

    plaintext = ""
    for i in range(0, len(ciphertext), 2):
        a = ciphertext[i]
        b = ciphertext[i + 1]
        plaintext += decrypt_pair(matrix, a, b)

    return plaintext

# Example usage:
cipher_text = "UGRMKCSXHMUFMKBTOXGCMVATLUKV"  # example from previous encryption
plain_text = playfair_decrypt(cipher_text, key="monarchy")
print("\nDecrypted Text:", plain_text)

"""# **Q5**"""

import numpy as np

def hill_cipher_encrypt(plain_text, key):
    """
    Encrypts a plaintext using the Hill cipher with a given key.
    """
    key_matrix = np.array([ord(char) - ord('A') for char in key]).reshape(3, 3)
    print("---- Encryption Process ----")
    print("Key Matrix:")
    print(key_matrix)

    plain_text = plain_text.upper().replace(" ", "")
    cipher_text = ""

    # Pad the plaintext if its length is not a multiple of 3
    if len(plain_text) % 3 != 0:
        padding_needed = 3 - (len(plain_text) % 3)
        plain_text += 'X' * padding_needed

    # Encrypt the plaintext
    for i in range(0, len(plain_text), 3):
        chunk = np.array([ord(char) - ord('A') for char in plain_text[i:i+3]]).reshape(3, 1)
        encrypted_chunk = np.dot(key_matrix, chunk) % 26
        # Correctly extract number from array before converting to chr
        cipher_text += "".join([chr(int(num[0]) + ord('A')) for num in encrypted_chunk])

    return cipher_text

def hill_cipher_decrypt(cipher_text, key):
    """
    Decrypts a ciphertext using the Hill cipher with a given key.
    """
    key_matrix = np.array([ord(char) - ord('A') for char in key]).reshape(3, 3)
    plain_text = ""

    print("\n---- Decryption Process ----")

    # --- FIX STARTS HERE ---
    # Handle ciphertexts with invalid length
    cipher_text = cipher_text.upper()
    if len(cipher_text) % 3 != 0:
        original_len = len(cipher_text)
        new_len = original_len - (original_len % 3)
        print(f"Warning: Ciphertext length ({original_len}) is not a multiple of 3.")
        cipher_text = cipher_text[:new_len]
        print(f"Truncating to length {new_len} for decryption: '{cipher_text}'")
    # --- FIX ENDS HERE ---


    # Calculate the determinant of the key matrix
    det = int(np.round(np.linalg.det(key_matrix)))
    print(f"Determinant of the Key Matrix: {det}")

    # Calculate the modular inverse of the determinant
    det_inv = -1
    for i in range(26):
        if (det * i) % 26 == 1:
            det_inv = i
            break

    if det_inv == -1:
        return "The key is not invertible, and the ciphertext cannot be decrypted with this key."
    print(f"Modular Multiplicative Inverse of the Determinant (mod 26): {det_inv}")


    # Calculate the inverse of the key matrix
    # Using np.linalg.inv() can introduce floating point inaccuracies
    # A more robust method for integer matrix inversion is used here
    adjugate_matrix = np.round(det * np.linalg.inv(key_matrix)).astype(int)
    inv_key_matrix = (det_inv * adjugate_matrix) % 26

    print("\nInverse Key Matrix:")
    print(inv_key_matrix)

    # Decrypt the ciphertext
    for i in range(0, len(cipher_text), 3):
        chunk = np.array([ord(char) - ord('A') for char in cipher_text[i:i+3]]).reshape(3, 1)
        decrypted_chunk = np.dot(inv_key_matrix, chunk) % 26
        # Correctly extract number from array before converting to chr
        plain_text += "".join([chr(int(num[0]) + ord('A')) for num in decrypted_chunk])

    return plain_text

# --- Main Program ---

# Example with a valid length plaintext
plain_text = "Pay more money"
key = "GYBNQKURP"

print(f"Original Plaintext: '{plain_text}'")
print(f"Key: {key}\n")

# Encryption
encrypted_text = hill_cipher_encrypt(plain_text, key)
print(f"\nEncrypted Ciphertext: {encrypted_text}")

# Decryption
decrypted_text = hill_cipher_decrypt(encrypted_text, key)
print(f"\nDecrypted Text: {decrypted_text}")


# --- Cryptanalysis of the original problem ---
print("\n\n--- Cryptanalysis on 'fupcmtgzkyukbqfjhuktzkkixtta' ---")
cipher_text_problem = "fupcmtgzkyukbqfjhuktzkkixtta"
key_problem = "GYBNQKURP"
print(f"Ciphertext: {cipher_text_problem}")
print(f"Key: {key_problem}")

decrypted_problem_text = hill_cipher_decrypt(cipher_text_problem, key_problem)
print(f"\nDecrypted Text from original problem: {decrypted_problem_text}")

"""# **Q6**"""

import math

def create_matrix(text, key_length):
    text = text.replace(" ", "").upper()
    extra_chars = (key_length - len(text) % key_length) % key_length
    text += 'X' * extra_chars  # Padding with X
    rows = len(text) // key_length
    matrix = [list(text[i * key_length:(i + 1) * key_length]) for i in range(rows)]
    return matrix

def transpose(matrix, key):
    key_order = sorted(list(zip(key, range(len(key)))))
    col_indices = [index for _, index in key_order]

    transposed = []
    for i in col_indices:
        transposed.extend([row[i] for row in matrix])
    return ''.join(transposed)

def inverse_transpose(text, key):
    key_length = len(key)
    rows = len(text) // key_length
    matrix = [['' for _ in range(key_length)] for _ in range(rows)]

    key_order = sorted(list(zip(key, range(key_length))))
    col_indices = [index for _, index in key_order]

    # Fill columns by order
    k = 0
    for col in col_indices:
        for row in range(rows):
            matrix[row][col] = text[k]
            k += 1

    # Flatten row-wise
    decrypted = ''.join([''.join(row) for row in matrix])
    return decrypted

def double_transposition_encrypt(plaintext, key):
    key_digits = [int(d) for d in str(key)]

    # First transposition
    matrix1 = create_matrix(plaintext, len(key_digits))
    stage1 = transpose(matrix1, key_digits)

    # Second transposition
    matrix2 = create_matrix(stage1, len(key_digits))
    stage2 = transpose(matrix2, key_digits)

    return stage2

def double_transposition_decrypt(ciphertext, key):
    key_digits = [int(d) for d in str(key)]

    # First inverse transposition
    stage1 = inverse_transpose(ciphertext, key_digits)

    # Second inverse transposition
    stage2 = inverse_transpose(stage1, key_digits)

    # Optionally strip padding Xs
    return stage2.rstrip('X')

# Example usage
plaintext = "Enemy attacks tonight"
key = 31452

cipher_text = double_transposition_encrypt(plaintext, key)
print("Cipher Text:", cipher_text)

decrypted_text = double_transposition_decrypt(cipher_text, key)
print("Decrypted Text:", decrypted_text)

from math import gcd

def additive_inverses(n):
    print(f"\nAdditive Inverse Pairs in Z{n}:")
    for a in range(n):
        b = (-a) % n
        print(f"{a} + {b} ≡ 0 mod {n}")

def multiplicative_inverses(n):
    print(f"\nMultiplicative Inverse Pairs in Z{n}:")
    for a in range(1, n):
        if gcd(a, n) == 1:
            # Find b such that (a*b) % n == 1
            for b in range(1, n):
                if (a * b) % n == 1:
                    print(f"{a} × {b} ≡ 1 mod {n}")
                    break  # Only need the first such b

def find_inverses(n):
    additive_inverses(n)
    multiplicative_inverses(n)

# Example usage
n = int(input("Enter the value of n for Zn: "))
find_inverses(n)

def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0  # gcd, x, y
    else:
        gcd, x1, y1 = extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return gcd, x, y

def additive_inverse(b, n):
    return (-b) % n

def multiplicative_inverse(b, n):
    gcd_val, x, _ = extended_gcd(b, n)
    if gcd_val != 1:
        return None  # Inverse does not exist
    else:
        return x % n

# Input from user
b = int(input("Enter the integer b: "))
n = int(input("Enter the modulus n (Zn): "))

add_inv = additive_inverse(b, n)
mult_inv = multiplicative_inverse(b, n)

print(f"\nAdditive Inverse of {b} in Z{n} is: {add_inv}")
if mult_inv is not None:
    print(f"Multiplicative Inverse of {b} in Z{n} is: {mult_inv}")
else:
    print(f"Multiplicative Inverse of {b} in Z{n} does not exist (gcd ≠ 1)")