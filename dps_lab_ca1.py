# -*- coding: utf-8 -*-
"""DPS_Lab_CA1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aV3Ivi08VvI27IDXu6CAiDEgxRjViEua

# **2-WAY SERVER CLIENT - AES 128**
"""

#SERVER.PY
#IMPORTING LIBRARIES
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os
import socket
import threading

# AES-128 key (16 bytes)
KEY = b'ThisIsASecretKey'

def encrypt_message(message: str, key: bytes) -> bytes:
    iv = os.urandom(16)  # 128-bit IV
    cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(message.encode()) + encryptor.finalize()
    return iv + ciphertext  # IV prepended

def decrypt_message(encrypted_data: bytes, key: bytes) -> str:
    iv = encrypted_data[:16]
    ciphertext = encrypted_data[16:]
    cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return plaintext.decode()

HOST = '127.0.0.1'
PORT = 65432

def receive_messages(conn):
    while True:
        encrypted_data = conn.recv(1024)
        if not encrypted_data:
            break
        try:
            message = decrypt_message(encrypted_data, KEY)
            print(f"[Encrypted] {encrypted_data.hex()}")
            if message.lower() == 'exit':
                print("[Client]: exit")
                print("[Server] Connection Terminated")
                conn.close()
                break
            print(f"[Client]: {message}")
        except Exception as e:
            print("[Server] Decryption error:", e)

def send_messages(conn):
    while True:
        msg = input()
        encrypted = encrypt_message(msg, KEY)
        conn.sendall(encrypted)
        if msg.lower() == 'exit':
            print("[Server] Connection Terminated")
            conn.close()
            break

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
    server.bind((HOST, PORT))
    server.listen()
    print(f"[Server] Listening on {HOST}:{PORT}")
    conn, addr = server.accept()
    print(f"[Server] Connected by {addr}")

    threading.Thread(target=receive_messages, args=(conn,), daemon=True).start()
    send_messages(conn)

#CLIENT.PY
#IMPORTING LIBRARIES
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os
import socket
import threading

# AES-128 key (16 bytes)
KEY = b'ThisIsASecretKey'

def encrypt_message(message: str, key: bytes) -> bytes:
    iv = os.urandom(16)  # 128-bit IV
    cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(message.encode()) + encryptor.finalize()
    return iv + ciphertext  # IV prepended

def decrypt_message(encrypted_data: bytes, key: bytes) -> str:
    iv = encrypted_data[:16]
    ciphertext = encrypted_data[16:]
    cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return plaintext.decode()


HOST = '127.0.0.1'
PORT = 65432

def receive_messages(sock):
    while True:
        encrypted_data = sock.recv(1024)
        if not encrypted_data:
            break
        try:
            message = decrypt_message(encrypted_data, KEY)
            print(f"[Encrypted] {encrypted_data.hex()}")
            if message.lower() == 'exit':
                print("[Server]: exit")
                print("[Client] Connection Terminated")
                sock.close()
                break
            print(f"[Server]: {message}")
        except Exception as e:
            print("[Client] Decryption error:", e)

def send_messages(sock):
    while True:
        msg = input()
        encrypted = encrypt_message(msg, KEY)
        sock.sendall(encrypted)
        if msg.lower() == 'exit':
            print("[Client] Connection Terminated")
            sock.close()
            break

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:
    client.connect((HOST, PORT))
    print(f"[Client] Connected to server at {HOST}:{PORT}")

    threading.Thread(target=receive_messages, args=(client,), daemon=True).start()
    send_messages(client)

"""# **2-WAY SERVER CLIENT - RSA**"""

#SERVER.PY
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes
import socket
import threading

# Generate RSA key pair
def generate_key_pair():
    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    public_key = private_key.public_key()
    return private_key, public_key

# Serialize public key to send over socket
def serialize_public_key(public_key):
    return public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

# Deserialize public key from bytes
def deserialize_public_key(public_bytes):
    return serialization.load_pem_public_key(public_bytes)

# Encrypt with receiver's public key
def encrypt_message(message: str, public_key) -> bytes:
    return public_key.encrypt(
        message.encode(),
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

# Decrypt with receiver's private key
def decrypt_message(encrypted_data: bytes, private_key) -> str:
    return private_key.decrypt(
        encrypted_data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    ).decode()

HOST = '127.0.0.1'
PORT = 65432

# Generate server keypair
server_private_key, server_public_key = generate_key_pair()
client_public_key = None  # to be received

def receive_messages(conn):
    global client_public_key
    while True:
        try:
            encrypted_data = conn.recv(4096)
            if not encrypted_data:
                break
            message = decrypt_message(encrypted_data, server_private_key)
            print(f"[Encrypted] {encrypted_data.hex()}")

            if message.lower() == "exit":
                print("[Client]: exit")
                print("[Server] Connection Terminated")
                conn.close()
                break

            print(f"[Client]: {message}")
        except Exception as e:
            print("[Server] Error:", e)
            break

def send_messages(conn):
    global client_public_key
    while True:
        msg = input()
        encrypted = encrypt_message(msg, client_public_key)
        conn.sendall(encrypted)
        if msg.lower() == "exit":
            print("[Server] Connection Terminated")
            conn.close()
            break

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    print(f"[Server] Listening on {HOST}:{PORT}")
    conn, addr = s.accept()
    print(f"[Server] Connected by {addr}")

    # Exchange public keys
    conn.sendall(serialize_public_key(server_public_key))
    client_key_bytes = conn.recv(1024)
    client_public_key = deserialize_public_key(client_key_bytes)

    threading.Thread(target=receive_messages, args=(conn,), daemon=True).start()
    send_messages(conn)

#CLIENT.PY
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes
import socket
import threading

# Generate RSA key pair
def generate_key_pair():
    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    public_key = private_key.public_key()
    return private_key, public_key

# Serialize public key to send over socket
def serialize_public_key(public_key):
    return public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

# Deserialize public key from bytes
def deserialize_public_key(public_bytes):
    return serialization.load_pem_public_key(public_bytes)

# Encrypt with receiver's public key
def encrypt_message(message: str, public_key) -> bytes:
    return public_key.encrypt(
        message.encode(),
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

# Decrypt with receiver's private key
def decrypt_message(encrypted_data: bytes, private_key) -> str:
    return private_key.decrypt(
        encrypted_data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    ).decode()


HOST = '127.0.0.1'
PORT = 65432

# Generate client keypair
client_private_key, client_public_key = generate_key_pair()
server_public_key = None  # to be received

def receive_messages(sock):
    global server_public_key
    while True:
        try:
            encrypted_data = sock.recv(4096)
            if not encrypted_data:
                break
            message = decrypt_message(encrypted_data, client_private_key)
            print(f"[Encrypted] {encrypted_data.hex()}")

            if message.lower() == "exit":
                print("[Server]: exit")
                print("[Client] Connection Terminated")
                sock.close()
                break

            print(f"[Server]: {message}")
        except Exception as e:
            print("[Client] Error:", e)
            break

def send_messages(sock):
    global server_public_key
    while True:
        msg = input()
        encrypted = encrypt_message(msg, server_public_key)
        sock.sendall(encrypted)
        if msg.lower() == "exit":
            print("[Client] Connection Terminated")
            sock.close()
            break

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    print(f"[Client] Connected to server at {HOST}:{PORT}")

    # Exchange public keys
    server_key_bytes = s.recv(1024)
    server_public_key = deserialize_public_key(server_key_bytes)
    s.sendall(serialize_public_key(client_public_key))

    threading.Thread(target=receive_messages, args=(s,), daemon=True).start()
    send_messages(s)

"""# **2 WAY SERVER CLIENT - CAESER CIPHER**"""

#SERVER.py
import socket
import threading

SHIFT = 3  # You can change this for a different Caesar shift

def encrypt_message(message: str, shift=SHIFT) -> str:
    encrypted = ''
    for char in message:
        if char.isalpha():
            base = ord('A') if char.isupper() else ord('a')
            encrypted += chr((ord(char) - base + shift) % 26 + base)
        else:
            encrypted += char
    return encrypted

def decrypt_message(ciphertext: str, shift=SHIFT) -> str:
    return encrypt_message(ciphertext, -shift)


HOST = '127.0.0.1'
PORT = 65432

def receive_messages(conn):
    while True:
        encrypted_data = conn.recv(1024).decode()
        if not encrypted_data:
            break
        decrypted = decrypt_message(encrypted_data)
        print(f"[Encrypted] {encrypted_data}")
        if decrypted.lower() == 'exit':
            print("[Client]: exit")
            print("[Server] Connection Terminated")
            conn.close()
            break
        print(f"[Client]: {decrypted}")

def send_messages(conn):
    while True:
        msg = input()
        encrypted = encrypt_message(msg)
        conn.sendall(encrypted.encode())
        if msg.lower() == 'exit':
            print("[Server] Connection Terminated")
            conn.close()
            break

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    print(f"[Server] Listening on {HOST}:{PORT}")
    conn, addr = s.accept()
    print(f"[Server] Connected by {addr}")

    threading.Thread(target=receive_messages, args=(conn,), daemon=True).start()
    send_messages(conn)

#CLIENT.py
import socket
import threading

SHIFT = 3  # You can change this for a different Caesar shift

def encrypt_message(message: str, shift=SHIFT) -> str:
    encrypted = ''
    for char in message:
        if char.isalpha():
            base = ord('A') if char.isupper() else ord('a')
            encrypted += chr((ord(char) - base + shift) % 26 + base)
        else:
            encrypted += char
    return encrypted

def decrypt_message(ciphertext: str, shift=SHIFT) -> str:
    return encrypt_message(ciphertext, -shift)

HOST = '127.0.0.1'
PORT = 65432

def receive_messages(sock):
    while True:
        encrypted_data = sock.recv(1024).decode()
        if not encrypted_data:
            break
        decrypted = decrypt_message(encrypted_data)
        print(f"[Encrypted] {encrypted_data}")
        if decrypted.lower() == 'exit':
            print("[Server]: exit")
            print("[Client] Connection Terminated")
            sock.close()
            break
        print(f"[Server]: {decrypted}")

def send_messages(sock):
    while True:
        msg = input()
        encrypted = encrypt_message(msg)
        sock.sendall(encrypted.encode())
        if msg.lower() == 'exit':
            print("[Client] Connection Terminated")
            sock.close()
            break

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    print(f"[Client] Connected to server at {HOST}:{PORT}")

    threading.Thread(target=receive_messages, args=(s,), daemon=True).start()
    send_messages(s)

"""# **2 WAY COMMUNICATION - AFFINE CIPHER**"""

#SERVER.PY
from math import gcd
import socket
import threading

# Alphabet size
M = 26

# Default keys (can be customized)
A = 5  # Must be coprime with 26
B = 8

def modinv(a, m):
    # Modular inverse of a under mod m
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    raise ValueError(f"No modular inverse for a={a} mod {m}")

def encrypt_char(char, a, b):
    if char.isalpha():
        base = ord('A') if char.isupper() else ord('a')
        x = ord(char) - base
        enc = (a * x + b) % M
        return chr(enc + base)
    return char

def decrypt_char(char, a, b):
    if char.isalpha():
        base = ord('A') if char.isupper() else ord('a')
        x = ord(char) - base
        a_inv = modinv(a, M)
        dec = (a_inv * (x - b)) % M
        return chr(dec + base)
    return char

def encrypt_message(message: str, a=A, b=B) -> str:
    if gcd(a, M) != 1:
        raise ValueError("Multiplicative key 'a' must be coprime with 26.")
    return ''.join(encrypt_char(c, a, b) for c in message)

def decrypt_message(ciphertext: str, a=A, b=B) -> str:
    if gcd(a, M) != 1:
        raise ValueError("Multiplicative key 'a' must be coprime with 26.")
    return ''.join(decrypt_char(c, a, b) for c in ciphertext)

HOST = '127.0.0.1'
PORT = 65432

def receive_messages(conn):
    while True:
        encrypted_data = conn.recv(1024).decode()
        if not encrypted_data:
            break
        decrypted = decrypt_message(encrypted_data, A, B)
        print(f"[Encrypted] {encrypted_data}")
        if decrypted.lower() == 'exit':
            print("[Client]: exit")
            print("[Server] Connection Terminated")
            conn.close()
            break
        print(f"[Client]: {decrypted}")

def send_messages(conn):
    while True:
        msg = input()
        encrypted = encrypt_message(msg, A, B)
        conn.sendall(encrypted.encode())
        if msg.lower() == 'exit':
            print("[Server] Connection Terminated")
            conn.close()
            break

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    print(f"[Server] Listening on {HOST}:{PORT}")
    conn, addr = s.accept()
    print(f"[Server] Connected by {addr}")

    threading.Thread(target=receive_messages, args=(conn,), daemon=True).start()
    send_messages(conn)

#CLIENT.PY
from math import gcd
import socket
import threading

# Alphabet size
M = 26

# Default keys (can be customized)
A = 5  # Must be coprime with 26
B = 8

def modinv(a, m):
    # Modular inverse of a under mod m
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    raise ValueError(f"No modular inverse for a={a} mod {m}")

def encrypt_char(char, a, b):
    if char.isalpha():
        base = ord('A') if char.isupper() else ord('a')
        x = ord(char) - base
        enc = (a * x + b) % M
        return chr(enc + base)
    return char

def decrypt_char(char, a, b):
    if char.isalpha():
        base = ord('A') if char.isupper() else ord('a')
        x = ord(char) - base
        a_inv = modinv(a, M)
        dec = (a_inv * (x - b)) % M
        return chr(dec + base)
    return char

def encrypt_message(message: str, a=A, b=B) -> str:
    if gcd(a, M) != 1:
        raise ValueError("Multiplicative key 'a' must be coprime with 26.")
    return ''.join(encrypt_char(c, a, b) for c in message)

def decrypt_message(ciphertext: str, a=A, b=B) -> str:
    if gcd(a, M) != 1:
        raise ValueError("Multiplicative key 'a' must be coprime with 26.")
    return ''.join(decrypt_char(c, a, b) for c in ciphertext)

HOST = '127.0.0.1'
PORT = 65432

def receive_messages(sock):
    while True:
        encrypted_data = sock.recv(1024).decode()
        if not encrypted_data:
            break
        decrypted = decrypt_message(encrypted_data, A, B)
        print(f"[Encrypted] {encrypted_data}")
        if decrypted.lower() == 'exit':
            print("[Server]: exit")
            print("[Client] Connection Terminated")
            sock.close()
            break
        print(f"[Server]: {decrypted}")

def send_messages(sock):
    while True:
        msg = input()
        encrypted = encrypt_message(msg, A, B)
        sock.sendall(encrypted.encode())
        if msg.lower() == 'exit':
            print("[Client] Connection Terminated")
            sock.close()
            break

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    print(f"[Client] Connected to server at {HOST}:{PORT}")

    threading.Thread(target=receive_messages, args=(s,), daemon=True).start()
    send_messages(s)

"""For Additive cipher use,
A = 1
B = 3


For Multiplicative cipher use,
A = 5
B = 0
"""